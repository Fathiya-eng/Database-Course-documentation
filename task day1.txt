Database Course Documentation Report
1. Comparison: Flat File Systems vs Relational Databases

| Feature             | **Flat File Systems**                                                      | **Relational Databases (RDBMS)**                                        |
| ------------------- | -------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| **Structure**       | Stores data in plain text files (CSV, TXT). No strict structure or schema. | Organized into tables with rows and columns. Follows a defined schema.  |
| **Data Redundancy** | High redundancy — same data repeated in multiple files.                    | Low redundancy — data is normalized and stored once.                    |
| **Relationships**   | No built-in relationships. Data linking must be done manually.             | Supports relationships like 1-to-1, 1-to-many, many-to-many using keys. |
| **Example Usage**   | Simple applications, configuration files, small logs, spreadsheets.        | Enterprise systems, banking, HR systems, e-commerce platforms.          |
| **Drawbacks**       | - No data integrity                                                        |                                                                         |

Hard to manage large data

Difficult to update

Not secure | - Requires setup and maintenance

More complex than flat files

Needs trained personnel |
----------------------------------

2. DBMS Advantages Mind Map (Text Version)

Security

Role-based access control

Protects sensitive information

Integrity

Ensures accuracy and consistency

Uses constraints and validation rules

Backup

Automated backups

Data recovery after failure

Redundancy Control

Reduces duplicate data

Uses normalization and constraints

Concurrency

Allows multiple users to access data safely

Prevents conflicts or overwrites

Data Sharing

Multiple applications and users

Real-time access without conflict

You may include icons when drawing the mind map.

----------------------------
3. Roles in a Database System

1. System Analyst

Studies business requirements.

Determines what data the system needs.

Translates business needs into technical requirements.

2. Database Designer

Designs the database structure (ER Diagram).

Defines tables, relationships, keys, and constraints.

Ensures the design supports system requirements.

3. Database Developer

Implements the database structure using SQL.

Creates tables, views, stored procedures, triggers.

Works closely with designers and application developers.

4. DBA (Database Administrator)

Manages and maintains the database server.

Handles backups, security, performance tuning.

Ensures database availability and reliability.

5. Application Developer

Builds applications that connect to the database.

Uses programming languages and frameworks to access data.

Implements CRUD operations (Create, Read, Update, Delete).

6. BI Developer (Business Intelligence Developer)

Builds dashboards and analytical reports.

Works on data warehousing, ETL pipelines, and analytics tools.

Helps organizations make data-driven decisions.
----------------------------------------------

Types of Databases

1. Relational vs Non-Relational Databases
Relational Databases (SQL)

Structure: Organized into tables with rows and columns.

Data Format: Follows a strict schema.

Query Language: SQL (Structured Query Language).

Best For: Structured data with clear relationships.

Examples: MySQL, PostgreSQL, Oracle, SQL Server.

Use Case: Banking systems, HR systems, inventory systems.

Non-Relational Databases (NoSQL)

Structure: Flexible structure—documents, key-value, column-family, or graphs.

Schema: No fixed schema; allows unstructured or semi-structured data.

Best For: Big data, real-time apps, high scalability.

Examples:

MongoDB (Document Database): Stores data as JSON-like documents.

Use case: E-commerce product catalogs, social media profiles.

Cassandra (Column-Family Database): Designed for high availability and scalability.

Use case: Logging systems, IoT data, time-series analytics.

2. Centralized vs Distributed vs Cloud Databases
Centralized Database

Location: Stored in one central location (one server).

Advantages: Easy to manage, more control, consistent data.

Disadvantages: Single point of failure.

Use Case: Small companies, local applications, school systems.

Distributed Database

Location: Data is stored across multiple sites/servers.

Advantages: High reliability, fast access, fault tolerance.

Disadvantages: More complex to manage.

Use Case: Global companies, airline reservation systems, telecom networks.

Cloud Database

Location: Hosted on cloud platforms (AWS, Azure, GCP).

Advantages: Scalable, low cost, automatic backups & maintenance.

Disadvantages: Requires internet; dependent on cloud provider.

Use Case: Modern web apps, mobile apps, SaaS products.

Use Case Examples Summary

| Type                       | Description             | Use Case Example          |
| -------------------------- | ----------------------- | ------------------------- |
| **Relational (SQL)**       | Structured, table-based | Banking, ERP systems      |
| **Non-Relational (NoSQL)** | Flexible, unstructured  | Social media, big data    |
| **Centralized**            | One server              | School database           |
| **Distributed**            | Multiple servers        | Telecom, airline booking  |
| **Cloud**                  | Hosted online           | Web apps, mobile backends |

-------------------------------------------------------
Cloud Storage and Databases

1. What is Cloud Storage and How Does It Relate to Databases?
Cloud Storage:

Cloud storage is a service that allows users to store files, data, and media on remote servers managed by cloud providers like Google Cloud, Amazon Web Services (AWS), and Microsoft Azure. Instead of saving data on physical local storage (like hard drives), the data is stored online and can be accessed from anywhere.

Relation to Databases:

While cloud storage typically stores unstructured data (documents, images, backups), cloud-based databases store structured or semi-structured data used by applications.

Cloud databases run on cloud servers and offer:

Automatic scalability

Remote access

High availability

Managed services (backups, updates, security)

So, cloud storage is like an online hard drive, while cloud databases are like powerful, managed database systems that run in the cloud.

2. Advantages of Cloud-Based Databases

Cloud databases such as Azure SQL, Amazon RDS, and Google Cloud Spanner provide several benefits:

 1. Scalability

They scale up or down automatically based on workload.

Supports large amounts of data without needing new hardware.

 2. High Availability & Reliability

Data is replicated across multiple servers or regions.

Ensures minimal downtime and disaster recovery.

 3. Reduced Maintenance

The cloud provider handles updates, backups, patching, and monitoring.

IT teams spend less time on manual administration.

 4. Cost Efficiency

Pay-as-you-go pricing model.

No need to purchase physical servers or storage devices.

 5. Global Access

Databases can be accessed from anywhere in the world.

Great for global applications needing fast response times.

 6. Security & Compliance

Includes features like encryption, access control, firewalls.

Complies with international standards (ISO, GDPR, etc.).

3. Disadvantages of Cloud-Based Databases
 1. Dependence on Internet Connectivity

Requires a stable internet connection.

Applications may fail if connectivity is poor.

 2. Ongoing Costs

Long-term cloud usage can become expensive.

High-performance tiers or large storage sizes increase costs.

 3. Limited Control

Users don’t control the physical hardware.

Some advanced configurations are restricted.

 4. Security Concerns

Although secure, storing data online always poses potential risks.

Vulnerable to misconfiguration or cyber attacks if not managed properly.

 5. Vendor Lock-in

Hard to migrate from one provider to another (e.g., AWS → Azure).

Differences in platforms and tools increase migration complexity.
---------------------------------------------------

Database Engines and Languages:

1. What is a Database Engine?

A database engine (or database management engine) is the core software component inside a Database Management System (DBMS) that handles:

Storing data

Retrieving data

Processing queries

Managing transactions

Ensuring data security, indexing, backup, and performance

Examples of DBMS that have engines: SQL Server, MySQL, Oracle, PostgreSQL.

Think of the engine as the “brain” of the database system.

2. Examples of Database Engines

Here are some widely-used engines:
 Microsoft SQL Server

A relational database system by Microsoft.

Provides powerful enterprise-level features.

 MySQL

Open-source and very popular for web applications.

Known for speed and ease of use.

 Oracle Database

Advanced commercial database known for high performance and scalability.

 PostgreSQL

Open-source, highly reliable, and supports advanced SQL features.

3. What Languages Do They Use?

Different engines use different SQL dialects:

| **Database Engine** | **Language / SQL Dialect**  | **Notes**                                           |
| ------------------- | --------------------------- | --------------------------------------------------- |
| **SQL Server**      | **T-SQL (Transact-SQL)**    | Microsoft’s SQL extension                           |
| **MySQL**           | **MySQL SQL dialect**       | Similar to ANSI SQL with some custom functions      |
| **Oracle**          | **PL/SQL (Procedural SQL)** | Oracle's procedural extension of SQL                |
| **PostgreSQL**      | **PL/pgSQL + ANSI SQL**     | Advanced standard SQL support + procedural language |

4. Is There a Relationship Between the Engine and the Language?

Yes — a strong relationship.

The engine determines which SQL dialect you use.
For example, you cannot write T-SQL (SQL Server) inside Oracle.

Each engine adds custom functions, data types, procedures, and syntax rules that work only in its environment.

Example:

T-SQL uses TOP for limiting rows → SELECT TOP 10 * FROM Students;

MySQL/PostgreSQL use LIMIT → SELECT * FROM Students LIMIT 10;

5. Can One Language Work Across Different Engines?
Short answer: Partially yes, but not fully.
✔ ANSI SQL works across all engines

Basic SQL commands like SELECT, INSERT, UPDATE, DELETE, WHERE, JOIN are the same everywhere.

Example (works on almost any engine):

SELECT first_name, last_name
FROM Employees
WHERE department = 'HR';

❌ Procedural or custom SQL cannot be shared

For example:

T-SQL stored procedures won’t run in MySQL.

Oracle PL/SQL functions won’t run in PostgreSQL.

MySQL-specific functions (like DATEDIFF) may not work in SQL Server.
----------------------------------------------

 1. Is engine-to-engine migration possible (SQL Server → MySQL, Oracle → PostgreSQL)?
Yes, it is possible.

Databases can be migrated between different engines using:

Common migration tools

SQL Server → MySQL

MySQL Workbench Migration Wizard

AWS Database Migration Service (DMS)

SQL Server Integration Services (SSIS)

Oracle → PostgreSQL

Oracle2PostgreSQL tools (ora2pg)

AWS Schema Conversion Tool (SCT)

EDB Migration Toolkit

BUT:

Each engine has a different SQL dialect, different data types, and different functionality, so automatic migration is rarely perfect. Manual rewriting is almost always needed.

 **. What are the challenges of engine-to-engine migration?**
1. Different SQL Dialects

SQL Server uses T-SQL
Oracle uses PL/SQL
PostgreSQL uses PL/pgSQL
MySQL uses its own procedural language

Stored procedures, triggers, and functions must often be rewritten manually.

2. Data Type Differences

Example:

SQL Server NVARCHAR(MAX) → MySQL LONGTEXT

Oracle NUMBER → PostgreSQL NUMERIC

SQL Server DATETIME → PostgreSQL TIMESTAMP

Not all types map 1-to-1.

3. Constraints & Indexes

Primary keys

Foreign keys

Unique constraints

Check constraints

Different engines enforce these differently.

4. Stored Procedures & Triggers

These rarely migrate automatically because:

Syntax is different

Functions behave differently

Some features exist in one engine but not in another

Example:

SQL Server’s IDENTITY must be converted to MySQL AUTO_INCREMENT or PostgreSQL SERIAL/BIGSERIAL.

5. Differences in Functions

Example:

SQL Server: GETDATE()

MySQL: NOW()

PostgreSQL: CURRENT_TIMESTAMP

Oracle: SYSDATE

String, math, and date functions also differ.

6. Performance tuning differences

Query optimizers work differently

Execution plans differ

Index types differ (e.g., PostgreSQL has more index types than MySQL)

7. Application compatibility issues

The application code (C#, Java, PHP, etc.) may need updates:

Connection strings

ORM configuration (EF Core, Hibernate, etc.)

SQL queries in the code

**.What should we consider before transferring?**
 1. Data Types Mapping

Create a mapping table, for example:
| SQL Server    | MySQL/PostgreSQL Equivalent |
| ------------- | --------------------------- |
| INT           | INT                         |
| BIGINT        | BIGINT                      |
| NVARCHAR(MAX) | TEXT / LONGTEXT             |
| DATETIME      | TIMESTAMP                   |
| BIT           | BOOLEAN                     |

2. Schema (Tables, Columns, Keys)

Check:

Primary keys

Foreign keys

Unique indexes

Composite keys

Check constraints

 3. Stored Procedures, Functions, and Triggers

Each one must be rewritten because the languages are different.

 4. Views & Materialized Views

Some engines:

Support materialized views (PostgreSQL)

Some don’t (MySQL)

 5. User Accounts & Permissions

Each DB engine handles:

Roles

Privileges

Authentication
differently.

 6. Transactions & Isolation Levels

Oracle uses MVCC differently from SQL Server.
PostgreSQL’s transaction model differs from MySQL’s engines.

 7. Data Consistency & Integrity

Plan how to migrate:

Large tables

Relationships

Null values

Default values

 8. Downtime Strategy

Choose:

Full migration (requires downtime)

Live migration (using replication tools like DMS)
------------------------------------------------

Logical vs. Physical Schema in Database Design

1. What is the Logical Schema?

The Logical Schema describes the abstract design of the database.
It focuses on what data is stored and how entities relate, without worrying about how the data will be saved on the computer.

Characteristics:

High-level, conceptual design

Shows entities, attributes, relationships

Independent of any specific database system

Often represented using ER diagrams or conceptual models

2. What is the Physical Schema?

The Physical Schema describes how the data is actually stored in the database system.

Characteristics:

Low-level, detailed storage design

Shows tables, columns, data types, indexes, constraints, and storage details

Depends on the DBMS (MySQL, SQL Server, Oracle…etc.)

3. What’s the difference between them?
| Feature         | Logical Schema                      | Physical Schema                 |
| --------------- | ----------------------------------- | ------------------------------- |
| Focus           | What data means                     | How data is stored              |
| Level           | High-level                          | Low-level                       |
| Representation  | ERD, conceptual diagrams            | SQL tables, datatypes, indexes  |
| DBMS Dependent? | No                                  | Yes                             |
| Includes        | Entities, attributes, relationships | Columns, datatypes, constraints |

4. Why is it important to understand both?

Understanding both schemas helps you:

Design a clear database structure

Avoid redundancy and conflicts

Improve performance (indexes, data types)

Communicate effectively between:

Business analysts (logical level)

Database engineers & developers (physical level)

Ensure the final database matches the real-world requirements

5. Example: Student entity in Logical vs Physical Schema
Logical Schema (ERD-style)

Entity: Student

StudentID

FirstName

LastName

Email

DateOfBirth

Has relationship: Enrolls in Course

This is conceptual, no data types, no SQL.

Physical Schema (SQL Table)
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Email VARCHAR(100) UNIQUE,
    DateOfBirth DATE,
    CreatedAt DATETIME DEFAULT GETDATE()
);


